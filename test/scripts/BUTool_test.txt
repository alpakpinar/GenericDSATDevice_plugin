# Add the device library and register the device
add_lib @LIB_DSAT_DEVICE
add_device GENERICDSAT @ADDRESS_TABLE_PATH

# Test that the zero padding (on default hex format works)
write TEST_1.SCRATCH.WORD_00 1
write TEST_1.SCRATCH.WORD_01 10
write TEST_1.SCRATCH.WORD_02 100
write TEST_1.SCRATCH.WORD_03 0x123
write TEST_1.SCRATCH.WORD_04 0x1000

# Signed and unsigned integers
write TEST_2.SCRATCH.UINTS.WORD_00 0x1
write TEST_2.SCRATCH.UINTS.WORD_01 0x100
write TEST_2.SCRATCH.SIGNED_INTS_16BIT.WORD_00 0x7FFF
write TEST_2.SCRATCH.SIGNED_INTS_16BIT.WORD_01 0x8FFF
write TEST_2.SCRATCH.SIGNED_INTS_8BIT.WORD_00 0x7F
write TEST_2.SCRATCH.SIGNED_INTS_8BIT.WORD_01 0x8F

# Test non-zero/zero display functionality
write TEST_4.SHOW_NONZERO.WORD_00 1
write TEST_4.SHOW_NONZERO.WORD_02 100

write TEST_4.SHOW_ZERO.WORD_00 1
write TEST_4.SHOW_ZERO.WORD_01 100

# Test enumerations
write TEST_5.ENUM_1.WORD_00 0
write TEST_5.ENUM_1.WORD_01 1
write TEST_5.ENUM_1.WORD_02 2
write TEST_5.ENUM_2.WORD_00 0
write TEST_5.ENUM_2.WORD_01 1
write TEST_5.ENUM_2.WORD_02 2

# Test the "m_" custom arithmetic format
write TEST_6.FLOATING_1.WORD_00 100
write TEST_6.FLOATING_1.WORD_01 10
write TEST_6.FLOATING_2.WORD_00 100
write TEST_6.FLOATING_2.WORD_01 10
write TEST_6.FLOATING_3.WORD_00 100
write TEST_6.FLOATING_2.WORD_01 10

# Test special 16-bit floating point values
write TEST_7.FP16.WORD_00 0x3555
write TEST_7.FP16.WORD_01 0x3bff
write TEST_7.FP16.WORD_02 0x7c00
write TEST_7.FP16.WORD_03 0xfc00
write TEST_7.FP16.WORD_04 0xc000
write TEST_7.FP16.WORD_05 0x7bff

# Test the _LO/_HI register value merging
write TEST_8.MERGED_64BIT.WORD_00_LO 0x1
write TEST_8.MERGED_64BIT.WORD_00_HI 0x1
write TEST_8.MERGED_64BIT.WORD_01_LO 0x100
write TEST_8.MERGED_64BIT.WORD_01_HI 0x100
write TEST_8.MERGED_64BIT.WORD_02_LO 0x10000000
write TEST_8.MERGED_64BIT.WORD_02_HI 0x10000000

# Generate status table and quit the program
status
quit
